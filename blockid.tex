\documentclass[conference]{IEEEtran}
\usepackage{amsmath, amssymb}
\usepackage{algorithm, algpseudocode}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}[theorem]

\title{AcBF: A Revokable Blockchain-based Identity Management Enabling Low-Latency Authentication}
\author{Jianan Hong, Jia Cheng, Chuan Zhang, Jiayue Zhou, and Yue Wu}
\begin{document}
\maketitle

\section{Introduction}
Blockchain is an attractive technology for distributed identity management due to its security features, such as append-only and non-tempering storage, decentralized consensus, and reliable trust establishment. Compared with traditional identity system, such as PKI (public key infrastructure), the character of blockchain-based method suits better in current and future network systems, where

\section{Preliminaries}

\subsection{Bilinear Pairing}
Let $\mathbb{G}_1$, $\mathbb{G}_2$ and $\mathbb{G}_T$ be 3 groups of prime order $p$. A pairing map $e:\mathbb{G}_1\times \mathbb{G}_2\rightarrow\mathbb{G}_T$ satisfies:
\begin{itemize}
	\item \textit{Bilinearity:} for all $(x,y, g_1, g_2) \in \mathbb{Z}_p^2\times \mathbb{G}_1\times \mathbb{G}_2$, $e(g_1^x, g_2^y) = e(g_1, g_2)^{xy}$;
	\item \textit{Non-degeneracy:} if $g_1, g_2$ are generators of $\mathbb{G}_1$ and $\mathbb{G}_2$, respectively, $e(g_1, g_2)$ generates $\mathbb{G}_T$;
	\item \textit{Efficiency:} It is efficient to compute $e(u,v)$ for all $(u, v) \in \mathbb{G}_1\times \mathbb{G}_2$.
\end{itemize}

According to the relationship of $\mathbb{G}_1$ and $\mathbb{G}_2$, there are three types of pairings \cite{GALBRAITH20083113}. 
In Type 1, $\mathbb{G}_1 = \mathbb{G}_2$; In Type 2, $\mathbb{G}_1 \neq \mathbb{G}_2$, but there is a unidirectional homomorphism $\phi:\mathbb{G}_2 \rightarrow \mathbb{G}_1$; An in Type 3, no PPT homomorphism algorithm exists between the two groups.
Overall speaking, Type 3 pairings are more secure and efficient to map, which is used in this paper.

[Concept and security assumptions]

\subsection{Bloom Filter}
Bloom filter (or BF for short) is a space-efficient data structure to record a set, in order to support membership queries \cite{Bloom1970, broder2004network}.
BF is an array of $m$ boolean bits, whose initial status is all zeros (denoted as $0^m$). Another parameter $k$ is the number of independent hashes, each of which maps a member to a random bit of BF. The follows describe the functions of BF, which are to be used in the later context.

\begin{itemize}
    \item $BF.Add(x)$: To add an element $x$ to BF, it respectively hashes $x$ with the $k$ hashes of BF, and sets each of the mapped bit to 1.
	\item $BF.Check(x)$: To query if $x$ has been added, it uses the $k$ hashes to map $x$ to a set of bits. If any of them is 0, it returns False; otherwise, it returns True. 
\end{itemize}

The $BF.Check()$ gives a False result with no doubt; whereas the True result has the potential to happen when the tested element has not been added, which means a false positive situation.


\section{System and Security Model}

\section{Construction}
\subsection{Revocation-Aware Block Format}
The block structure in this paper is basically similar to that of Bitcoin, except for the consideration of lightweight node awareness. Firstly, the storage cost of block header should be as short as possible with efficient query and sacrificing no security feature; Secondly, the block header alone can prompt every certificate revocation clearly. 

Taking into account the two issues, we redesign the 1) fields of block header, and 2) the tree structure of transactions. The header is a fixed length data, such that an unstructured storage can support fast addressing based on block height. The necessary fields are depicted in Table \ref{table:format}. Especially, as our later implementation uses 192-bit hash function and curves, the presented sizes of Previous hash and MHT (hash of merkle hash tree) are 24 bytes. The Flag filed is a main difference for the second consideration: it is a boolean variable to notify whether revocation events occur in this round.

The consensus filed depends on the used consensus method, e.g., it is a nonce for puzzle-like consensus method like PoW, or digital signature for permission-based consensus.


\begin{table}[h] 
	\caption{Block Header Format}\label{table:format}
	\centering
	\begin{tabular}{c|c|l}
		\hline
		Field & Size & Description \\
		\hline
		Height & 4 bytes & An incremental integer to identify this block \\
		Previous Hash & 24 bytes & A hash of previous block \\
		Flag & 1 bit & Indication of revocation \\
		MHT & 24 bytes & Hash of all transactions in this block \\
		Consensus & \textit{variable} & Some method proving the validity of block\\
		\hline
	\end{tabular}
\end{table}

All registered certificates (regarded as transactions) are structured in merkle hash tree as Section \ref{section:mht}, whose hash of root node is represented as $R_c$. There is also a slight difference for revocation awareness: if there is no revocation, $R_c$ is just the value of MHT; otherwise, MHT is assigned the hash of $R_a$ and the revocation transaction in this block (denoted as $R_x$). For certificates registered in this block, their SPV data includes $R_x$ in such case.


\subsection{System Procedures}
\subsubsection{Initialization}
xxx

\subsubsection{Certificate Register}
xxx


\subsubsection{Revocation}

\begin{algorithm}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
	\caption{Revocation Procedure of rCA}\label{alg:cap}
	\begin{algorithmic}[1]
		\Require $\mathbb{R}$ and $\mathbb{R}_x$ %\Comment{Set of user indexes to be revoked}
		\Ensure Revocation Transaction
		\State $L\gets \emptyset$
		\State $BF_{tmp} \gets 0^m$ \Comment{Empty bloom filter}
		\ForAll{$x \in \mathbb{R}$}
		\If{$BF.Check(x)$}
		\State $\Delta \gets Del(\Delta, x)$ \Comment{Section \ref{xxx}}
		\Else
		\State $BF_{tmp}.Add(x)$
		\EndIf
		\EndFor
		\State $BF \gets BF \lor BF_{tmp}$
		\State $\mathbb{R}_x \gets \mathbb{R}_x \bigcup \mathbb{R} $
	\end{algorithmic}
\end{algorithm}

\subsubsection{Block Generate and Broadcast}
The consensus nodes collect certificate register and revocation transactions 
\subsection{Parameter Determine for Bloom Filter}

The length of Bloom Filter in this paper can be dramatically decreased compared with other schemes for certificate revocation. This section gives a theoretical derivation for the relevant parameter.

Let $n, \delta$ be the possible maximal number of registered and revoked users, respectively. The remaining factor is system effect of user revocation: when revocation is executed in one consensus round, the expected affected users should be limited to $\theta$, which can be measured as the member amount of Accumulator $\Delta$. The measurement is feasible as:
\begin{itemize}
    \item Larger member amount in $\Delta$ causes larger probability that a user to be revoked has already in $\Delta$ and more other members to update their auxiliary information as \eqref{xxx}.
    \item The probability that innocent users applies for accumulator member affects the increase rate of $\theta$. Thus, $\theta$ also implies the effect when revocation is executed just in bloom filter.
\end{itemize}

Assume $m$ is the calculated hash length with $k$ hash functions in the Bloom filter. With $\delta$ users already be revoked, the probability can be measured as follows, that an legal user is erroneously claimed as a revoked one: 
\begin{align} 
    \Pr(1) \simeq (1 - e^{-k\delta/m})^k 
 \end{align}

The parameter $k$ can be individually optimized to minimize $\Pr(1)$ as $ k = \frac{m}{\delta}\ln 2$. Then, for $n$ valid users, the expected ... (limited to $\theta$) is 
\begin{align}\label{eq:bloomfilter}
    \theta = n \cdot (1 - e^{-k\delta/m})^{k} = 0.5^{\frac{m}{\delta}\ln 2}\cdot n
\end{align}
From \eqref{eq:bloomfilter}, the parameters of Bloom filter can be determined as 
\begin{align}
m = & \frac{\ln \frac{n}{\theta} \cdot \delta}{(\ln 2)^2} \simeq 2.08\delta \cdot\ln \frac{n}{\theta}\\
k = & \lfloor \ln \frac{n}{\theta} / \ln 2 \rceil \simeq \lfloor 1.44 \ln \frac{n}{\theta} \rceil
\end{align}

\section{Security Analysis of AcBF}
\begin{theorem}\label{theo:security}
	The AcBF identity management achieves sound and revocation-detectable user authentication for the lightweight-node verifier.
\end{theorem}

\begin{IEEEproof}
    A user without a registered certificate in public ledger (even without a revoked identity) will not forge an authentication due to the traditional certificate technique with trust SPV method. Thus, this proof mainly focuses on the revoked user. Formally, this theorem holds if a revoked user $\mathcal{A}$ wins the following challenges with negligible advantage.
    \begin{enumerate}
        \item With the knowledge of accumulator value $\Delta$, as well as any pair of other user's accumulator pair from authentication message \ref{section:authentication}, $\mathcal{A}$ tries to forge its auxiliary value.
        \item When $\mathcal{A}$ goes through a revocation based on member delete in $\Delta$, it tries to forge a new auxiliary value for the updated $\Delta$.
        \item When $\mathcal{A}$ is revoked in block $j$, it tries to hide the revocation fact during the broadcast of block header.
    \end{enumerate}

    The first 2 challenges require a secure cryptographic accumulator, and a strong blockchain protocol is in need for the last challenge. Hence, the demonstration of Theorem \ref{theo:security} can be derived from the following 2 lemmas.
\end{IEEEproof}
\begin{lemma}
    accumulator
\end{lemma}

\begin{lemma}
    If the consensus protocol is safe, the lightweight node is aware of every revocation when its ledger has \dots
\end{lemma}

\section{Performance Evaluation}

Compared with entire bloom filter with distinct parameters.

\section{Related Works}


\bibliographystyle{IEEEtran}
\bibliography{id}
\end{document}